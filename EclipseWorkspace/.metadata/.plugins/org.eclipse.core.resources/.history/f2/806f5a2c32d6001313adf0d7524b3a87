package worms.model;

import worms.model.Expression.Types;

public class ExpressionBinary extends Expression {
	
	public ExpressionBinary(Types expressionType, Type<?> e1, Type<?> e2) {
		super(expressionType);
		this.e1 = e1;
		this.e2 = e2;
	}
	
	private Type<?> e1;
	private Type<?> e2;

	@Override
	public Type<?> evaluate() {
		if (getExpressionType()==Types.ADDITION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())+((double)e2.getValue()));
		}
		if (getExpressionType()==Types.SUBTRACTION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())-((double)e2.getValue()));
		}
		if (getExpressionType()==Types.MULTIPLICATION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())*((double)e2.getValue()));
		}
		if (getExpressionType()==Types.DIVISION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())/((double)e2.getValue()));
		}
		if (getExpressionType()==Types.CONJUNCTION) {
			if ( !(e1.getValue() instanceof Boolean) || !(e2.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((boolean)e1.getValue())||((boolean)e2.getValue()));
		}
		if (getExpressionType()==Types.DISJUNCTION) {
			if ( !(e1.getValue() instanceof Boolean) || !(e2.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((boolean)e1.getValue())&&((boolean)e2.getValue()));
		}
		if (getExpressionType()==Types.LESSTHAN) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())<((double)e2.getValue()));
		}
		if (getExpressionType()==Types.LESSTHANOREQUALTO) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())<=((double)e2.getValue()));
		}
		if (getExpressionType()==Types.GREATERTHAN) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())>((double)e2.getValue()));
		}
		if (getExpressionType()==Types.GREATERTHANOREQUALTO) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())=>((double)e2.getValue()));
		}
		if (getExpressionType()==Types.EQUALTO)
			return null;
		if (getExpressionType()==Types.DIFFERENTFROM)
			return null;
		throw new ModelException("Evaluation of expression failed."); //TODO do something else than throwing an exception?
	}

}
