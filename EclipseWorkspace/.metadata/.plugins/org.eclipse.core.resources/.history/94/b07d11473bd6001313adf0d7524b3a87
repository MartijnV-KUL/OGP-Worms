package worms.model;

import be.kuleuven.cs.som.annotate.Basic;
import be.kuleuven.cs.som.annotate.Raw;

public abstract class Expression {
	
	private final Expression.Types type;
	private final Type<?> e1;
	private final Type<?> e2;
	
	protected Expression(Expression.Types type, Type<?> e1) {
		this.type = type;
		this.e1 = e1;
	}
	
	public Expression(Expression.Types type, Type<?> e1, Type<?> e2) {
		this.type = type;
		this.e1 = e1;
		this.e2 = e2;
	}
	
	public Types getType() {
		return type;
	}
	
	public static enum Types {
		VARIABLE,
		DOUBLE,
		TRUE,
		FALSE,
		NULL,
		SELF,
		ADDITION,
		SUBTRACTION,
		MULTIPLICATION,
		DIVISION,
		SQUAREROOT,
		SINE,
		COSINE,
		CONJUNCTION,
		DISJUNCTION,
		NEGATION,
		LESSTHAN,
		LESSTHANOREQUALTO,
		GREATERTHAN,
		GREATERTHANOREQUALTO,
		EQUALTO,
		DIFFERENTFROM,
		GETX,
		GETY,
		GETRADIUS,
		GETDIR,
		GETAP,
		GETMAXAP,
		SAMETEAM,
		SEARCHOBJ,
		ISWORM,
		ISFOOD;
	}
	
	public Type<?> evaluate() {
		if (getType()==Expression.Types.VARIABLE)
			return e1;
		if (getType()==Expression.Types.DOUBLE)
			return e1;
		if (getType()==Expression.Types.TRUE)
			return new Type<Boolean>(true);
		if (getType()==Expression.Types.FALSE)
			return new Type<Boolean>(false);
		if (getType()==Expression.Types.NULL)
			return new Type<Entity>();
		if (getType()==Expression.Types.SELF)
			return e1; //TODO this brings a reference to the actual object out. is that desired?
		if (getType()==Expression.Types.SQUAREROOT) {
			if ( !(e1.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(Math.sqrt((double)e1.getValue()));
		}
		if (getType()==Expression.Types.SINE) {
			if ( !(e1.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(Math.sin((double)e1.getValue()));
		}
		if (getType()==Expression.Types.COSINE) {
			if ( !(e1.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(Math.cos((double)e1.getValue()));
		}
		if (getType()==Expression.Types.NEGATION) {
			if ( !(e1.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Boolean>(~((boolean)e1.getValue()));
		}
		if (getType()==Expression.Types.GETX) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e1.getValue()).getX());
			if ( e1.getValue() instanceof Food )
				return new Type<Double>(((Food)e1.getValue()).getX());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.GETY) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e1.getValue()).getY());
			if ( e1.getValue() instanceof Food )
				return new Type<Double>(((Food)e1.getValue()).getY());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.GETRADIUS) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e1.getValue()).getRadius());
			if ( e1.getValue() instanceof Food )
				return new Type<Double>(Food.getRadius());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.GETDIR) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e1.getValue()).getDirection());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.GETAP) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Double>((double) ((Worm)e1.getValue()).getActionPoints());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.GETMAXAP) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Double>((double) ((Worm)e1.getValue()).getMaxActionPoints());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.SAMETEAM) {
			if ( e1.getValue() instanceof Worm )
				return new Type<Boolean>(getStatement().getProgram().getWorm().getTeam()==((Worm)e1.getValue()).getTeam());
			getStatement().getProgram().typeErrorOccurred();
		}
		if (getType()==Expression.Types.SEARCHOBJ) {
			double x = getStatement().getProgram().getWorm().getX();
			double y = getStatement().getProgram().getWorm().getY();
			double angle = getStatement().getProgram().getWorm().getDirection() + e1.getValue();
			double resolution = 0.1*getStatement().getProgram().getWorm().getRadius();
			while ( getStatement().getProgram().getWorm().getWorld().isWithinBoundaries(x,y) ) {
				for ( Worm worm : getStatement().getProgram().getWorm().getWorld().getAliveWorms() ) {
					if ( World.isOverlapping(worm.getX(), worm.getY(), worm.getRadius(), x, y, 0) )
						return new Type<Entity>(new Entity(worm));
				}
			}
			return new Type<Entity>();
		}
		if (getType()==Expression.Types.ISWORM)
			return new Type<Boolean>(e1.getValue() instanceof Worm);
		if (getType()==Expression.Types.ISFOOD)
			return new Type<Boolean>(e1.getValue() instanceof Food);
		if (getType()==Expression.Types.ADDITION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())+((double)e2.getValue()));
		}
		if (getType()==Expression.Types.SUBTRACTION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())-((double)e2.getValue()));
		}
		if (getType()==Expression.Types.MULTIPLICATION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())*((double)e2.getValue()));
		}
		if (getType()==Expression.Types.DIVISION) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())/((double)e2.getValue()));
		}
		if (getType()==Expression.Types.CONJUNCTION) {
			if ( !(e1.getValue() instanceof Boolean) || !(e2.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((boolean)e1.getValue())||((boolean)e2.getValue()));
		}
		if (getType()==Expression.Types.DISJUNCTION) {
			if ( !(e1.getValue() instanceof Boolean) || !(e2.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((boolean)e1.getValue())&&((boolean)e2.getValue()));
		}
		if (getType()==Expression.Types.LESSTHAN) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())<((double)e2.getValue()));
		}
		if (getType()==Expression.Types.LESSTHANOREQUALTO) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())<=((double)e2.getValue()));
		}
		if (getType()==Expression.Types.GREATERTHAN) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())>((double)e2.getValue()));
		}
		if (getType()==Expression.Types.GREATERTHANOREQUALTO) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())>=((double)e2.getValue()));
		}
		if (getType()==Expression.Types.EQUALTO) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())==((double)e2.getValue())); //TODO only correct for primitive Expression.Types. Since casting to the primitive type double, this is correct.
		}
		if (getType()==Expression.Types.DIFFERENTFROM) {
			if ( !(e1.getValue() instanceof Number) || !(e2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)e1.getValue())!=((double)e2.getValue()));
		}

		getStatement().getProgram().typeErrorOccurred();
	}

	
	
// {{ Terminated

	private boolean terminated;
	
	@Basic
	public boolean isTerminated() {
		return terminated;
	}
	
	public void terminate() {
		terminated = true;
	}
	
	
	// }}

}
