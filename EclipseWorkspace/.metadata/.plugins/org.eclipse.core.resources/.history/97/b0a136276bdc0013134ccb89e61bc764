package worms.model;

import worms.model.ModelException;
import be.kuleuven.cs.som.annotate.Basic;
import be.kuleuven.cs.som.annotate.Raw;

public abstract class Expression {
	
	private final int line;
	private final int column;
	
	public Expression(int line, int column) {
		this.line = line;
		this.column = column;
	}
	
	public int getLine() {
		return line;
	}
	public int getColumn() {
		return column;
	}
	
	public abstract Type<?> evaluate(); 
	
	public Type<?> evaluate() {
		if (getType()==Expression.Types.TRUE)
			return new Type<Boolean>(true);
		if (getType()==Expression.Types.FALSE)
			return new Type<Boolean>(false);
		if (getType()==Expression.Types.NULL)
			return new Type<Entity>(null);
		if (getType()==Expression.Types.SELF) {
			return new Type<Entity>(new Entity(getStatement().getRootProgram().getWorm()));
		}
		
		getStatement().getProgram().typeErrorOccurred();
		return null;
	}
	
// {{ Statement Association

	private Statement statement;
	
	@Basic
	public Statement getStatement() {
		return statement;
	}
	
	@Raw
	void setStatement(Statement statement) {
		if (!canHaveAsStatement(statement))
			throw new ModelException("Invalid statement specified.");
		if (hasAStatement())
			throw new ModelException("Already has a statement");
		this.statement = statement;
	}
	
	private static boolean canHaveAsStatement(Statement statement) {
		if (statement == null)
			return false;
		if (statement.isTerminated())
			return false;
		return true;
	}
	
	protected boolean hasAStatement() {
		return (!(statement == null));
	}
	
	@Raw
	void removeStatement() {
		statement = null;
	}
	
// }}
		
// {{ Terminated

	private boolean terminated;
	
	@Basic
	public boolean isTerminated() {
		return terminated;
	}
	
	public void terminate() {
		terminated = true;
	}
	
	
	// }}

}
