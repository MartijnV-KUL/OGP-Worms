package worms.model;

import java.util.ArrayList;

import be.kuleuven.cs.som.annotate.Basic;
import be.kuleuven.cs.som.annotate.Raw;

public class Statement {

	private final Statement.Types type;
	private final ArrayList<Statement> statements;
	private final ArrayList<Expression> expressions;
	
	private Type<?> t;
	private final Object x;
	private final Expression e;
	private final Statement s1;
	private final Statement s2;
	private final ArrayList<Statement> statements;
	
	public Statement( Statement.Types type ) {
		this.type = type;
		this.t = null;
		this.x = null;
		this.e = null;
		this.s1 = null;
		this.s2 = null;
		this.statements = null;
	}
	
	public Statement( Type<?> t, Expression e ) {
		this.type = Statement.Types.ASSIGNMENT;
		this.t = t;
		this.x = null;
		this.e = e;
		this.s1 = null;
		this.s2 = null;
		this.statements = null;
	}
	
	public Statement( Statement.Types type, Object x, Statement s1 ) {
		this.type = type;
		this.t = null;
		this.x = x;
		this.e = null;
		this.s1 = s1;
		this.s2 = null;
		this.statements = null;
	}
	
	public Statement( Statement.Types type, Expression e, Statement s1 ) {
		this.type = type;
		this.t = null;
		this.x = null;
		this.e = e;
		this.s1 = s1;
		this.s2 = null;
		this.statements = null;
	}
	
	public Statement( Statement.Types type, Expression e, Statement s1, Statement s2 ) {
		this.type = type;
		this.t = null;
		this.x = null;
		this.e = e;
		this.s1 = s1;
		this.s2 = s2;
		this.statements = null;
	}
	
	public Statement( Statement.Types type, ArrayList<Statement> statements ) {
		this.type = type;
		this.t = null;
		this.x = null;
		this.e = null;
		this.s1 = null;
		this.s2 = null;
		this.statements = statements;
	}
	
	public Statement.Types getType() {
		return type;
	}

	public static enum Types {
		ASSIGNMENT,
		WHILE,
		FOREACH_WORM,
		FOREACH_FOOD,
		FOREACH_ANY,
		IFTHENELSE,
		PRINT,
		SEQUENCE,
		ACTION_TURN,
		ACTION_MOVE,
		ACTION_JUMP,
		ACTION_TOGGLEWEAP,
		ACTION_FIRE,
		ACTION_SKIP
	}

	public void execute() {
		if (getType()==Statement.Types.ASSIGNMENT)
			t = e.evaluate(); // note: refers to original object
		if (getType()==Statement.Types.WHILE) {
			if ( !(e.evaluate().getValue() instanceof Boolean) )
				getProgram().typeErrorOccurred();
			while ( (boolean) e.evaluate().getValue() )
				s1.execute();
		}
		if (getType()==Statement.Types.FOREACH_WORM) {
			if ( !(e.evaluate().getValue() instanceof Worm) )
				getProgram().typeErrorOccurred();
			for ( Worm worm : x ) {
				s1.execute();
			}
		}
		if (getType()==Statement.Types.FOREACH_FOOD) {
			if ( !(e.evaluate().getValue() instanceof Food) )
				getProgram().typeErrorOccurred();
			for ( Food food : x ) {
				s1.execute();
			}
		}
		if (getType()==Statement.Types.FOREACH_ANY) {
			
		}
		if (getType()==Statement.Types.IFTHENELSE) {
			
		}
		if (getType()==Statement.Types.PRINT) {
			
		}
		if (getType()==Statement.Types.SEQUENCE) {
			
		}
		if (getType()==Statement.Types.ACTION_TURN) {
			
		}
		if (getType()==Statement.Types.ACTION_MOVE) {
			
		}
		if (getType()==Statement.Types.ACTION_JUMP) {
			
		}
		if (getType()==Statement.Types.ACTION_TOGGLEWEAP) {
			
		}
		if (getType()==Statement.Types.ACTION_FIRE) {
			
		}
		if (getType()==Statement.Types.ACTION_SKIP) {
			
		}
		getProgram().typeErrorOccurred();
		
	}
	
	
// {{ Program Association

	private Program program;
	
	@Basic
	public Program getProgram() {
		return program;
	}
	
	@Raw
	void setProgram(Program program) {
		if (!canHaveAsProgram(program))
			throw new ModelException("Invalid program specified.");
		if (hasAProgram())
			throw new ModelException("Already has a program");
		this.program = program;
	}
	
	private static boolean canHaveAsProgram(Program program) {
		if (program == null)
			return false;
		if (program.isTerminated())
			return false;
		return true;
	}
	
	protected boolean hasAProgram() {
		return (!(program == null));
	}
	
	@Raw
	void removeProgram() {
		program = null;
	}
	
// }}
	
// {{ Terminated

	private boolean terminated;
	
	@Basic
	public boolean isTerminated() {
		return terminated;
	}
	
	public void terminate() {
		if (hasAProgram())
			program.removeStatement(this);
		terminated = true;
	}
	
	
	// }}

}
