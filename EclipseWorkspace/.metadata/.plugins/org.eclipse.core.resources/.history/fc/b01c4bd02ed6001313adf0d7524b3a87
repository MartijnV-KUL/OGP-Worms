package worms.model;

public class ExpressionSingle extends Expression {
	
	protected ExpressionSingle(Types expressionType, Type<?> e) {
		super(expressionType);
		this.e = e;
	}

	private Type<?> e;

	@Override
	public Type<?> evaluate() throws ModelException {
		if (getExpressionType()==Types.VARIABLE)
			return e;
		if (getExpressionType()==Types.DOUBLE)
			return e;
		if (getExpressionType()==Types.TRUE)
			return new Type<Boolean>(true);
		if (getExpressionType()==Types.FALSE)
			return new Type<Boolean>(false);
		if (getExpressionType()==Types.NULL)
			return new Type<Entity>(null);
		if (getExpressionType()==Types.SELF)
			return e; //TODO this brings a reference to the actual object out. is that desired?
		if (getExpressionType()==Types.GETX) {
			if ( e.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e.getValue()).getX());
			if ( e.getValue() instanceof Food )
				return new Type<Double>(((Food)e.getValue()).getX());
			throw new ModelException("TYPE ERROR: Cannot request entity's x coordinate."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.GETY) {
			if ( e.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e.getValue()).getY());
			if ( e.getValue() instanceof Food )
				return new Type<Double>(((Food)e.getValue()).getY());
			throw new ModelException("TYPE ERROR: Cannot request entity's y coordinate."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.GETRADIUS) {
			if ( e.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e.getValue()).getRadius());
			if ( e.getValue() instanceof Food )
				return new Type<Double>(Food.getRadius());
			throw new ModelException("TYPE ERROR: Cannot request entity's radius."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.GETDIR) {
			if ( e.getValue() instanceof Worm )
				return new Type<Double>(((Worm)e.getValue()).getDirection());
			throw new ModelException("TYPE ERROR: Cannot request entity's radius."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.GETAP) {
			if ( e.getValue() instanceof Worm )
				return new Type<Double>((double) ((Worm)e.getValue()).getActionPoints());
			throw new ModelException("TYPE ERROR: Cannot request entity's action points."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.GETMAXAP) {
			if ( e.getValue() instanceof Worm )
				return new Type<Double>((double) ((Worm)e.getValue()).getMaxActionPoints());
			throw new ModelException("TYPE ERROR: Cannot request entity's maximum action points."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.SAMETEAM) {
			if ( e.getValue() instanceof Worm )
				return new Type<Boolean>(getStatement().getProgram().getWorm().getTeam()==((Worm)e.getValue()).getTeam());
			throw new ModelException("TYPE ERROR: Cannot request entity's team."); //TODO do something else than throwing an exception?
		}
		if (getExpressionType()==Types.SEARCHOBJ) {
			double x = getStatement().getProgram().getWorm().getX();
			double y = getStatement().getProgram().getWorm().getY();
			double angle = getStatement().getProgram().getWorm().getDirection() + e.getValue();
			double resolution = 0.1*getStatement().getProgram().getWorm().getRadius();
			while ( getStatement().getProgram().getWorm().getWorld().isWithinBoundaries(x,y) ) {
				if getStatement().getProgram().getWorm().getWorld().isOverlapping
			}
			return new Type<Entity>(null);
		}
		if (getExpressionType()==Types.ISWORM)
			return null;
		if (getExpressionType()==Types.ISFOOD)
			return null;
		throw new ModelException("Evaluation of expression failed"); //TODO do something else than throwing an exception?
	}

}
