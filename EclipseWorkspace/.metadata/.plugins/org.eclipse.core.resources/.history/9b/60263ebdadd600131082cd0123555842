package worms.model;

public class ExpressionBinary extends Expression {

	private final Type<?> t1;
	private final Type<?> t2;
	
	public ExpressionBinary(Expression.Types type, Type<?> t1, Type<?> t2) {
		super(type);
		this.t1 = t1;
		this.t2 = t2;
	}
	

	public Type<?> evaluate() {
		if (getType()==Expression.Types.ADDITION) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())+((double)t2.getValue()));
		}
		if (getType()==Expression.Types.SUBTRACTION) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())-((double)t2.getValue()));
		}
		if (getType()==Expression.Types.MULTIPLICATION) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())*((double)t2.getValue()));
		}
		if (getType()==Expression.Types.DIVISION) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())/((double)t2.getValue()));
		}
		if (getType()==Expression.Types.CONJUNCTION) {
			if ( !(t1.getValue() instanceof Boolean) || !(t2.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((boolean)t1.getValue())||((boolean)t2.getValue()));
		}
		if (getType()==Expression.Types.DISJUNCTION) {
			if ( !(t1.getValue() instanceof Boolean) || !(t2.getValue() instanceof Boolean) )
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((boolean)t1.getValue())&&((boolean)t2.getValue()));
		}
		if (getType()==Expression.Types.LESSTHAN) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())<((double)t2.getValue()));
		}
		if (getType()==Expression.Types.LESSTHANOREQUALTO) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())<=((double)t2.getValue()));
		}
		if (getType()==Expression.Types.GREATERTHAN) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())>((double)t2.getValue()));
		}
		if (getType()==Expression.Types.GREATERTHANOREQUALTO) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())>=((double)t2.getValue()));
		}
		if (getType()==Expression.Types.EQUALTO) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())==((double)t2.getValue())); //TODO only correct for primitive Expression.Types. Since casting to the primitive type double, this is correct.
		}
		if (getType()==Expression.Types.DIFFERENTFROM) {
			if ( !(t1.getValue() instanceof Number) || !(t2.getValue() instanceof Number) ) //TODO instance of "Double" or "Number"?
				getStatement().getProgram().typeErrorOccurred();
			return new Type<Double>(((double)t1.getValue())!=((double)t2.getValue()));
		}

		getStatement().getProgram().typeErrorOccurred();
		return null;
	}
	
}
