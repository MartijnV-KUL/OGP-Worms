package worms.model;

import java.util.ArrayList;

import be.kuleuven.cs.som.annotate.Basic;

public class Projectile {
	
	
	private final double gravitationalAcceleration = 9.80665;
	
	private final double massRifleProjectile = 0.010;
	private final double rifleProjectileForce = 1.5;
	
	private final double massBazookaProjectile = 0.300;
	
	private ArrayList<Projectile> projectileCollection;
	
	private Worm worm;
	
	public void setProjectilePosition() {
		if (!isValidX(worm.getX() + worm.getRadius() * Math.cos(worm.getDirection())))
			throw new ModelException("The x-coordinate is invalid.");
		if (!isValidY(worm.getX() + worm.getRadius() * Math.sin(worm.getDirection())))
			throw new ModelException("The y-coordinate is invalid.");
		this.x = worm.getX() + worm.getRadius() * Math.cos(worm.getDirection());
		this.y = worm.getY() + worm.getRadius() * Math.sin(worm.getDirection());
	}
	
	public double getX() {
		return this.x;
	}
	
	public boolean isValidX(double x) {
		return (!Double.isNaN(x));
	}
	
	public double getY() {
		return this.y;
	}
	
	public boolean isValidY(double y) {
		return (!Double.isNaN(y));
	}
	
	public double getDirection() {
		return worm.getDirection();
	}
	
	public double getBazookaForce() {
		// TODO Assignment says nothing about how the force is scaled? Only information is that it lays between 2.5 and 9.5?
		return -1;
	}
	
	//TODO
	public boolean wormIsHit() {
		return false;
	}
	
	//TODO
	public void shootRifle() {
		
	}
	
	//TODO
	public void shootBazooka(int yield) {
		
	}
	
	
	

	public double[] jumpStep(double t) {
		return worm.jumpStep(t);
	}
	
	//TODO
	public double jumpTime(double timeStep) {
		return -1;
	}
	
	//TODO
	public void Shoot(int propulsionYield) {
		
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	public Projectile(double x, double y, double direction, int propulsionYield) {
		setPosition(new Position(x, y, direction));
		setPropulsionYield(propulsionYield);
	}

	public double getRadius() throws ModelException {
		if (!hasAWeapon())
			throw new ModelException("This projectile does not have a weapon assigned to it.");
		// m = rho*V
		// V = (4/3)*pi*r^3
		// r = ((m/rho)*(3/4)/pi)^(1/3)
		double m = weapon.getProjectileMass();
		double rho = 7800;
		double pi = Math.PI;
		return Math.pow((m/rho)*(3/4)*(1/pi), 1/3);
	}
	
	public void jump() {
		
	}
	
	
// {{ Position
	
	private Position position;
	
	/**
	 * Basic inspector that returns the position object of the projectile. 
	 * @return The position object of the projectile.
	 */
	@Basic
	public Position getPosition() {
		return position;
	}
	
	public void setPosition(Position position) {
		if (!isValidPosition(position))
			throw new ModelException("Invalid position specified");
		this.position = position;
	}
	
	public boolean isValidPosition(Position position) {
		if (position==null)
			return false;
		return true;
	}
	
	
	// }}
	
// {{ Propulsion Yield
	
	private int propulsionYield;
	
	@Basic
	public int getPropulsionYield() {
		return propulsionYield;
	}
	
	public void setPropulsionYield(int propulsionYield) throws ModelException {
		if (!isValidPropulsionYield(propulsionYield))
			throw new ModelException("Invalid propulsion yield.");
		this.propulsionYield = propulsionYield;
	}
	
	public boolean isValidPropulsionYield(int propulsionYield) {
		if (propulsionYield<0)
			return false;
		if (propulsionYield>100)
			return false;
		return true;
	}
	
	// }}
	
// {{ Terminated
	
	private boolean terminated;
	
	@Basic
	public boolean isTerminated() {
		return terminated;
	}
	
	public void terminate() {
		if (hasAWorld())
			world.removeProjectile();
		terminated = true;
	}
	
	// }}
	
// {{ World Association
	
	private World world;
	
	@Basic
	public World getWorld() {
		return world;
	}
	
	public void setWorld(World world) throws ModelException {
		if (!canHaveAsWorld(world))
			throw new ModelException("Invalid world specified.");
		if (hasAWorld())
			throw new ModelException("Already has a world.");
		this.world = world;
	}
	
	public boolean canHaveAsWorld(World world) {
		if (world==null)
			return false;
		if (world.isTerminated())
			return false;
		return true;
	}
	
	public boolean hasAWorld() {
		return(!(world==null));
	}
	
	public boolean hasAsWorld(World world) {
		return (this.world==world);
	}
	
	public void removeWorld() {
		world = null;
	}
	
	// }}
	
// {{ Weapon Association
	
	private Weapon weapon;
	
	@Basic
	public Weapon getWeapon() {
		return weapon;
	}
	
	public void setWeapon(Weapon weapon) throws ModelException {
		if (!canHaveAsWeapon(weapon))
			throw new ModelException("Invalid weapon specified.");
		if (hasAWeapon())
			throw new ModelException("Already has a weapon.");
		this.weapon = weapon;
	}
	
	public boolean canHaveAsWeapon(Weapon weapon) {
		if (weapon==null)
			return false;
		if (weapon.isTerminated())
			return false;
		return true;
	}
	
	public boolean hasAWeapon() {
		return (!(weapon==null));
	}
	
	public boolean hasAsWeapon(Weapon weapon) {
		return (this.weapon==weapon);
	}
	
	public void removeWeapon() {
		weapon = null;
	}
	
	
	// }}
}
