package worms.model;

import java.util.ArrayList;

import be.kuleuven.cs.som.annotate.Basic;
import be.kuleuven.cs.som.annotate.Raw;

public abstract class Statement {
	
	public Statement(ArrayList<Statement> statements, ArrayList<Expression> expressions) {
		for ( Statement statement : statements ) {
			this.statements.add(statement);
		}
		for ( Expression expression : expressions ) {
			this.expressions.add(expression);
		}
	}

//		ASSIGNMENT,
//		WHILE,
//		FOREACH,
//		IFTHENELSE,
//		PRINT,
//		SEQUENCE,
//		ACTION
	
// {{ Program Association

	private Program program;
	
	@Basic
	public Program getProgram() {
		return program;
	}
	
	@Raw
	void setProgram(Program program) {
		if (!canHaveAsProgram(program))
			throw new ModelException("Invalid program specified.");
		if (hasAProgram())
			throw new ModelException("Already has a program");
		this.program = program;
	}
	
	private static boolean canHaveAsProgram(Program program) {
		if (program == null)
			return false;
		if (program.isTerminated())
			return false;
		return true;
	}
	
	protected boolean hasAProgram() {
		return (!(program == null));
	}
	
	@Raw
	void removeProgram() {
		program = null;
	}
	
// }}
	
// {{ Parent Statement Association

	private Statement parentStatement;
	
	@Basic
	public Statement getParentStatement() {
		return parentStatement;
	}
	
	@Raw
	void setParentStatement(Statement statement) {
		if (!canHaveAsParentStatement(statement))
			throw new ModelException("Invalid statement specified.");
		if (hasAParentStatement())
			throw new ModelException("Already has a statement");
		this.parentStatement = statement;
	}
	
	private static boolean canHaveAsParentStatement(Statement statement) {
		if (statement == null)
			return false;
		if (statement.isTerminated())
			return false;
		return true;
	}
	
	protected boolean hasAParentStatement() {
		return (!(parentStatement == null));
	}
	
	@Raw
	void removeParentStatement() {
		parentStatement = null;
	}
	
	// }}
	
	// {{ Statements Association
	
	private final ArrayList<Statement> statements = new ArrayList<Statement>();
	
	@Basic
	public ArrayList<Statement> getStatements() {
		return statements;
	}
	
	public void addStatement(Statement statement) throws ModelException {
		if (!canHaveAsStatement(statement))
			throw new ModelException("Invalid statement specified.");
		if (hasAsStatement(statement))
			throw new ModelException("Statement already in world.");
		statement.setParentStatement(this);
		statements.add(statement);
	}
	
	private static boolean canHaveAsStatement(Statement statement) {
		if (statement==null)
			return false;
		if (statement.isTerminated())
			return false;
		return true;
	}
	
	private boolean hasAsStatement(Statement statement) {
		return statements.contains(statement);
	}
	
	public void removeStatement(Statement statement) throws ModelException {
		if (!hasAsStatement(statement))
			throw new ModelException("Statement not found.");
		statement.removeParentStatement();
		statements.remove(statement);
	}
	
	private void removeAllStatements() {
		for ( Statement statement : statements ) {
			statement.removeParentStatement();
			removeStatement(statement);
		}
	}
	
	// }}
	
	// {{ Expressions Association
	
	private final ArrayList<Expression> expressions = new ArrayList<Expression>();
	
	@Basic
	public ArrayList<Expression> getExpressionss() {
		return expressions;
	}
	
	public void addExpression(Expression expression) throws ModelException {
		if (!canHaveAsExpression(expression))
			throw new ModelException("Invalid expression specified.");
		if (hasAsExpression(expression))
			throw new ModelException("Expression already in world.");
		expression.setStatement(this);
		statements.add(expression);
	}
	
	private static boolean canHaveAsExpression(Expression expression) {
		if (expression==null)
			return false;
		if (expression.isTerminated())
			return false;
		return true;
	}
	
	private boolean hasAsExpression(Expression expression) {
		return expressions.contains(expression);
	}
	
	public void removeExpression(Expression expression) throws ModelException {
		if (!hasAsExpression(expression))
			throw new ModelException("Statement not found.");
		expression.removeStatement();
		statements.remove(expression);
	}
	
	private void removeAllExpressions() {
		for ( Expression expression : expressions ) {
			expression.removeStatement();
			removeExpression(expression);
		}
	}
	
	// }}
	
// {{ Terminated

	private boolean terminated;
	
	@Basic
	public boolean isTerminated() {
		return terminated;
	}
	
	public void terminate() {
		removeAllStatements();
		removeAllExpressions();
		terminated = true;
	}
	
	
	// }}

}
