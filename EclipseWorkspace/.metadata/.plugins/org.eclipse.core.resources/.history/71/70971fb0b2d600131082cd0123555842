package worms.model;

import java.util.ArrayList;
import java.util.HashMap;

import be.kuleuven.cs.som.annotate.Basic;
import be.kuleuven.cs.som.annotate.Raw;
import worms.gui.game.IActionHandler;
import worms.model.ModelException;
import worms.model.programs.ParseOutcome;

public class Program {
	
	private static ParseOutcome<?> parser;
	
	public Program() {
		System.out.println("This class has no implementation yet!");
	}

	public static ParseOutcome<?> parseProgram(String programText, IActionHandler handler) {
		//TODO
		return parser;
	}

	public boolean isWellFormed(Program program) {
		return getStatement().isWellFormed();
	}
	
	public void typeErrorOccurred() {
		//TODO
		// Page 16 of assignment about type errors:
//		Such errors must be detected at runtime, i.e. during the execution of the
//		program. As explained before, runtime errors should be handled in a total
//		manner. That is, execution of the program stops and subsequent runs of the
//		program return immediately.
	}
	
	private HashMap<String,Expression> variables;
	
	public void assignVariable(String variable, Expression e) {
		variables.put(variable, e);
	}
	
	public Expression getVariable(String variable) {
		Expression e = variables.get(variable);
		if (e==null)
			return new ExpressionVariable(variable);
		return e;
	}
	
	private int currentLine;
	private int nbStatementsExecuted;
	private static final int maxNbStatementsExecutions = 1000;
	public int getNbStatementsExecuted() {
		return nbStatementsExecuted;
	}
	public int getMaxNbStatementsExecutions() {
		return maxNbStatementsExecutions;
	}
	
	public void runProgram() {
		if (nbStatementsExecuted>=maxNbStatementsExecutions) {
			
		} else if (/*was already running; somehow keep track of current execution line or something*/) {
			
		} else {
			getStatement().execute();
		}
	}
	
	public void stopProgram() {
		//TODO
	}
	

	
// {{ Associations
	
// {{ Worm Association
	
	private Worm worm;
	
	/**
	 * Returns the worm the weapon belongs to.
	 * 
	 * @return	The worm the weapon belongs to.
	 */
	@Basic
	public Worm getWorm() {
		return worm;
	}
	
	/**
	 * Method to set a new worm to a program.
	 * 
	 * @param 	worm
	 * 			The new worm.
	 * 
	 * @post	| new.getWorm() == worm
	 * @throws 	ModelException
	 * 			| if (!canHaveAsWorm(worm)
	 * 			|	throw new ModelException
	 * 			| if (hasAWorm())
	 * 			|	throw new ModelException
	 */
	@Raw
	void setWorm(Worm worm) throws ModelException {
		if (!canHaveAsWorm(worm))
			throw new ModelException("Invalid worm specified.");
		if (hasAWorm())
			throw new ModelException("Already has a worm.");
		this.worm = worm;
	}
	
	/**
	 * Checks if the given worm is valid.
	 * 
	 * @param 	worm
	 * 			The given worm.
	 * 
	 * @return	| if (worm == null)
	 * 			| 	return false
	 * 			| if (worm.isTerminated())
	 * 			|	return false
	 * 			| else
	 * 			|	return true
	 */
	private static boolean canHaveAsWorm(Worm worm) {
		if (worm==null)
			return false;
		if (worm.isTerminated())
			return false;
		return true;
	}
	
	/**
	 * Checks if a worm is not null.
	 * 
	 * @return	(!(worm == null))
	 */
	private boolean hasAWorm() {
		return(!(worm==null));
	}
	
	/**
	 * Method to remove a worm.
	 * 
	 * @post	| new.getWorm() == null
	 */
	@Raw
	void removeWorm() {
		worm = null;
	}
	
// }}
	
// {{ Statement Association

	private Statement statement;
	
	@Basic
	public Statement getStatement() {
		return statement;
	}
	
	void setStatement(Statement statement) {
		if (!canHaveAsStatement(statement))
			throw new ModelException("Invalid statement specified.");
		if (hasAStatement())
			throw new ModelException("Already has a statement");
		statement.setProgram(this);
		this.statement = statement;
	}
	
	private static boolean canHaveAsStatement(Statement statement) {
		if (statement == null)
			return false;
		if (statement.isTerminated())
			return false;
		return true;
	}
	
	protected boolean hasAStatement() {
		return (!(statement == null));
	}
	
	void removeStatement() {
		if (hasAStatement())
			statement.removeProgram();
		statement = null;
	}
	
// }}
	
// }}
		
// {{ Terminated
	
	private boolean terminated;
	
	@Basic
	public boolean isTerminated() {
		return terminated;
	}
	
	public void terminate() {
		if (hasAWorm())
			worm.removeProgram();
		removeStatement();
		terminated = true;
	}
	
	
	// }}
	
	
	
}
