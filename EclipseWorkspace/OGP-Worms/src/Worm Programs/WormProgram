/**	A program for a computer-controlled worm.
 *	The worm first searches for nearby food, afterwards it searches for the nearest enemy worm, moves near it and shoots.
 *
 *	@note	Possible getters:
 *			GetX, GetY, GetRadius, GetDir, GetAP, GetMaxAP, GetHP, GetMaxHP
 *
 *			Possible statements
 *			Turn, Move, Jump, ToggleWeap, Fire, Skip
 */
 
entity worm;
entity nearestWorm;
entity food;

bool foodPresent := false;
double x;
double y;
double direction;
double wormX;
double wormY;
double wormDirection;
double radius;
double wormDistance;
double distanceToNearestWorm;
double foodDistance;
double distanceToNearestFood;
double foodX;
double foodY;
double angle;

double actionPoints;
double maxActionPoints;
double hitPoints;
double maxHitPoints;

//Define variables
actionPoints := getAP self;
radius := getradius self;
x := getx self;
y := gety self;

//Check if there is food present in the world.
food := searchObject(0);
	if (isFood(food))
		foodPresent := true;
		
//First try to eat food if it is not too far away, then do all the rest.
if (foodPresent) {
	//Find nearest food
	foreach(Food, f) do {
		foodX := getx f;
		foodY := gety f;
		foodDistance := sqrt( (((x - foodX) * (x - foodX)) + ((y - foodY) * (y - foodY))) );
		if (foodDistance < 3 * radius) {		// Eat only food when it is not too far away (I chose 3 times the radius).
			//TODO	How can you define where the food is located and make the worm turn to it, so it can move and eat it?
			//		The arc-functions are not defined, so using them is impossible?
		}
	}
}
while (actionPoints > 20) do {

	maxActionPoints := getMaxAP self;
	nearestWorm := null;
	
	//Find nearest enemy worm
	foreach(worm, w) do {
		if (w != self) {
			wormX := getx w;
			wormY := gety w;
			wormDistance := sqrt( (((x - wormX) * (x - wormX)) + ((y - wormY) * (y - wormY))) ;
			if (nearestWorm == null) {
				if ( !sameTeam(nearestWorm) ) {
					nearestWorm := w;
					distanceToNearestWorm := wormDistance;
				}
				else skip;
			} 
			else {
				if (wormDistance < distanceToNearestWorm) {
					if ( !sameTeam(nearestWorm) ) {
						nearestWorm := w;
						distanceToNearestWorm := wormDistance;
					}
					else skip;
				}
			}
		}
	}
	
	//Change direction so that it is facing the nearest worm
	direction := getdir self;
	angle := ( (Math.abs(wormY - y) / distanceToNearestWorm) * (Math.PI / 180) );	//This is the angle that the worm must have to face
	double turnDirection;															//the target worm.
	turnDirection := direction - angle;
	
	turn(turnDirection);
	
	//Move a few times towards the target worm
	move; move; move;		//TODO: How to implement a for-loop when it's not possible to use integers?
	
	//Fire at the worm.
	toggleWeap;
	if ( !sameTeam(nearestWorm) )
		fire 100;
	else skip;
}
else jump;		//If the worm has not enough actionPoints left to perform a move or turn, just jump.
	